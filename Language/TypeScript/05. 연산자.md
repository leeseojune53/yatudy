# 05. 연산자

# 5.1. 기본 연산자

## 5.1.1. 산술 연산자

타입스크립트는 자바스크립트와 동일한 산술 연산자를 지원한다. 산술 연산자로는 더하기, 빼기, 곱하기, 나누기 같은 사칙연산과 나머지 연산을 수행할 수 있는 % 연산자가 있다. 이에 더해 타입스크립트는 ES7의 지수 연산자인 **를 지원하므로 Math.pow를 대체해 사용할 수 있다. 아래 예제를 보자.

```tsx
// 산술 연산자 --- #1
console.log(10 + 2, 10 - 2, 10 * 2, 10 / 2, 10 % 2);
console.log(10 ** 3);

// 타입이 다른 피연산자 간의 더하기 연산 --- #2
console.log(1 + "happy");
console.log(false + "happy");
```

지수 연산자가 포함된 10**3은 ES6나 ES5로 컴파일하면 Math.pow(10, 3)로 변환돼 컴파일 된다.

타입이 다른 피연산자 간의 더하기 연산을 보여주는데, 문자열 간의 더하기 연산은 자바스크립트처럼 문자열 결합으로 인식한다.

타입스크립트에는 더하기 연산자를 허용하지 않는 예외 상황이 있다. 예를 들어, 아래와 같은 연산식이 있다고 해보자.

```tsx
1 + false
```

위와 같은 식을 자바스크립트에서는 false 값을 0으로 인식해 정상적으로 실행하며 결과는 1이다. 그런데 타입스크립트에서는 타입 오류가 있는 것으로 판별한다.

타입스크립트에서는 **숫자 값과 불리언 값은 연산할 수 없으며**, 자바스크립트처럼 false 값을 0으로 인식하지 않는다.

또, 산술 연산자를 사용할 때 자바스크립트보다 엄격하게 타입을 검사하는 부분이 있다. 타입스크립트에서는 문자열 타입의 숫자를 연산식에 사용할 수 없다. 예를 들어, 아래와 같은 식이 있다고 해보자.

```tsx
10 / "2"
```

자바스크립트에서 위 식은 정상적으로 실행되며 결과는 5이다. 그러나 타입스크립트는 문자열 타입을 연산에 허용하지 않으므로 타입 오류가 발생한다.

위의 예제들 처럼 타입스크립트는 산술 연산자를 사용할 때 자바스크립트보다 엄격한 타입 검사를 함으로써 연산의 안정성을 높인다.

## 5.1.2. 비교, 논리, 조건 연산자

타입스크립트에서 조건문에 사용할 수 있는 연산자는 크게 세 부류가 있다.

- 비교 연산자
- 논리 연산자
- 조건 연산자

위 연산자 중에서 비교 연산자로는 다음과 같은 연산자가 있다.

[Ts 비교연산자](https://www.notion.so/0054a59b856b4a65a951edb78bb1149f)

Js는 피연산자 간에 타입이 달라도 비교할 수 있다. 예를 들어, 1==true, 1=="1"과 같이 타입이 달라도 비교 연산이 가능하다. 그런데 Ts는 1==true, 1=="1"과 같이 피연산자 간에 타입이 다르면 연산을 허용하지 않는다. 만약 1==true와 같은 연산을 한다면 오류 메시지가 나타난다.

이는 피연산자 간의 비교 연산을 할 때 타입 안전성을 고려하기 때문이다. 따라서 타입스크립트는 true == false와 같이타입이 같은 피연산자 간의 비교 연산만 허용한다. 특히 Ts는 "=="연산자 대신 "==="을, "≠" 연산자 대신 "≠="을 사용하기를 권장한다. "===", "≠=" 연산자를 사용해야 자바스크립트로 컴파일하고 나서도 타입 안정성을 보장할 수 있기 때문이다.

논리 연산자로는 다음 세 가지가 있다.

- &&
- ||
- !

비교 연산자와 달리 논리 연산자는 피연산자끼리 타입이 일치하지 않아도 된다. 따라서 1 && "true"와 같이 피연산자 간에 타입이 달라도 계산된다.

조건 연산자(?:)는 피연산자 3개를 사용하는 삼항 연산자이다. 조건 연산자의 형식은 아래와 같다.

```tsx
판별 조건 ? 표현식1 : 표현식2
```

판별 조건에 따라 표현식1과 표현식2 가운데 하나를 반환한다. 이때 판별 조건의 결과는 true/false여야 하고, true일 때는 표현식1이 실행되고, false일 때는 표현식2가 실행된다.

### 불리언 타입과 부정 연산자

불리언 타입인 true나 false는 그 자체로 참과 거짓이 자명하다 그런데 타입스크립트로 프로그래밍할 때 상황에 따라 타입 변환이 일어나기 때문에 true인지 false인지가 헷갈릴 때가 있다. 입력된 값이 숫자일 때와 문자열일 때가 그렇다. 예를 들어, 숫자 1의 타입은 number이다. 만약 숫자를 조건문에 넣으면 1은 더 이상 number가 아니라 참/거짓의 역할을 수행하며 true가 된다.

```tsx
console.log(!"hello", !!"hello");
console.log(!0, !!0, !1, !!1);
console.log(!true, !!true);
```

!! 즉 부정의 부정은 참이므로 그대로 참이다.

# 5.2. 디스트럭처링

타입스크립트는 ES6의 디스트럭처링(destructuring)을 지원한다. 디스트럭처링이라는 말의 뜻은 객체의 구조(structure)를 제거(de)한다는 의미가 있다. 디스트럭처링이라는 말의 뜻은 객체의 구조를 분해 후 할당이나 확장과 같은 연산을 수행합니다. 디스트럭처링은 자료형에 따라 다음과 같은 방식으로 나뉜다.

- 객체 디스트럭처링
- 배열 디스트럭처링

## 5.2.1. 객체 디스트럭처링

### 객체 디스트럭처링의 기본

객체 디스트럭처링 (object destructuring)은 객체 리터럴에서 변수명에 대응하는 속성값을 추출해 변수로 할당하는 데 유용하다. 이렇게 객체의 속성값을 변수에 할당하는 것을 디스트럭처링 할당(destructuring assignment)이라고 한다. 예를 들어, 객체를 변수에 디스트럭처링 할당하는 과정은 아래와 같이 이루어진다.

```tsx
let { id, country } = { id: "happy", country: 88 };
```

디스트럭처링 할당 표현식은 { id, country }와 같다. 디스트럭처링 할당 시 표현식 내부의 id와 country 변수는 객체의 속성값과 대응한다. 따라서 id에는 happy가, country에는 88이 할당된다.

디스트럭처링 할당 시 할당받을 속성이 없다면 표현식에 새롭게 정의한 변수를 선언해 초기화해 둘 수 있다.

```tsx
let { id, country=88 } = { id: "happy" };
```

디스트럭처링 할당 시 할당할 객체 속성에 새로운 이름을 부여해 할당하려면 속성 재명명(property renaming)을 이용할 수 있다.

### 디스트럭처링 매개변수 선언

함수 호출 시 객체 리터럴을 전달하고 객체 리터럴의 속성을 검사하는 것은 꽤 번거로운 작업이다.

```tsx
function printProfile(obj) {
	var name = "";
	var nationality = "";

	name = (obj.name == undeefined) ? "anonymous" : obj.name;
	nationality = (obj.name == undefined) ? "?" : obj.nationality;

	console.log(name);
	console.log(nationality);
}

printProfile({ name: "happy" });
```

위 코드의 printProfile 함수 내부를 보면 obj 객체의 속성에 name 속성이 있는지 검사하고, 없다면 기본값으로 "anonymous"를 할당하고, 있다면 객체의 속성을 할당받는다. 속성이 여럿이면 객체의 속성 검사를 위한 중복 코드가 발생한다. 객체의 특정 속성이 있는지 없는지를 타입에서 검사하고, 없다면 기본값을 할당할 수 있게 만들면 편리할 것이다. 이때 아래와 같은 형태로 함수에 디스트럭처링 매개변수를 선언한다.

```tsx
function printProfile({ 매개변수1, 매개변수2, ...}) { }
```

디스트럭처링 매개변수명은 객체의 속성명에 대응한다. 예를 들어, 함수에 디스트럭처링 매개변수를 선언해보자.

```tsx
function printProfile({ name, nationality = "?" }) {
	console.log(name);
	console.log(nationality);
}
printProfile({ name : "happy" });
```

디스트럭처링 매개변수인 name과 nationality는 전달받을 객체의 name 속성과 nationality 속성에 대응한다. 이때 디스트럭처링 매개변수는 기본값을 설정할 수 있다. 위 코드에서는 nationality의 기본값을 "?"로 설정함으로써 전달받은 객체에 속성이 없을때를 대비함. 위 코드에서 printProfile 함수는 반드시 객체를 전달해야 한다. 만약 객체 전달을 생략하려면 우항에 할당식을 추가해야 한다.

```tsx
function printProfile({name, nationality = "none"} = {name: "anonymous"}) {
    console.log(name, nationality);
}
printProfile();
printProfile({name: "happy"});
printProfile({name: "happy", nationality: "korea"})
```

위 예제는 디스트럭처링 매개변수가 할당받을 수 있게 우항에 객체를 뒀다.

이때 name은 우항식의 name 속성값을 할당받고 nationality는 기본값인 "none"가 설정돼 있으므로 생략할 수 있다.

```typescript
printProfile();
```

만약 객체에 name 속성만 포함한다면 antionality는 기본값이 있으므로 생략할 수 있다.

```typescript
printProfile({name: "happy"});
```

nationality 값을 객체에 담아 전달하면 기본값은 무시되고 전달한 nationality의 값인 "korea"가 전달된다.

```typescript
printProfile({name: "happy", nationality: "korea"});
```

### 객체 디스트럭처링 시 type 키워드 활용

type 키워드를 이용해 매개변수의 타입을 선언함으로써 객체 디스트럭처링을 수행할 수 있다. 이때 객체 디스트럭처링 시 사용할 타입은 type 키워드를 이용해 ㅐ아래와 같은 형식으로 선언한다.

```typescript
type C = { a: string, b?: number }
```

위와 같이 type 키워드를 이용해 타입 변수 C를 선언했다. 이렇게 선언한 타입 변수 C는 디스트럭처링 매개변수의 타입으로 활용할 수 있다.

```typescript
type C = { a: string, b?:number };
function fruit({a, b}: C): void {
    console.log(a, b);
}

fruit({a: "apple", b: 10});
fruit({a: "apple"});
```

### 배열 디스트럭처링

배열 디스트럭처링은 배열 요소를 간결한 방법으로 변수에 할당하는 방법을 제공한다.

```typescript
let numbers = ["one", "two", "three", "four", "five"];
```

numbers 배열에서 "onoe", "two" 요소를 추출해 nums1, nums2 변수에 할당하는 방법은

```typescript
let num1 = numbers[0];
let num2 = numbers[1];

let [nums1, nums2] = numbers;
```

위처럼 두 가지 방법이 있다.

```typescript
let [, , nums3, nums4] = numbers;

[nums4, nums3] = [nums3, nums4];
```

또한 쉼표를 이용해 부분 생략이 가능하고, 디스트럭처링을 활용해서 변숫값을 교체할 수 있다.



### 배열 요소를 함수의 디스트럭처링 매개변수로 전달

배열 디스트럭처링을 이용하면 함수에 배열을 전달할 때 배열 요소를 디스트럭처링 매개변수로 전달할 수 있다는 장점이 있다. 함수 호출 시 배열을 전달받아 처리하는 함수는 아래와 같이 선언한다.

```typescript
function f([first, second]: [number, string]) {...}
```

f라는 함수를 호출할 때 인수로 [100, "hello"] 배열을 전달하면 배열의 요소가 순서대로 매개변수 first와 second에 전달된다.

# 5.3. 전개 연산자

타입스크립트는 ES6의 전개 연산자(spread operator)를 지원한다. 전개 연산자는 '...'로 나타내며, 다음 세 가지 경우에 사용된다.

- 나머지 매개변수를 선언할 때
- 배열 요소를 확장할 떄
- 객체 요소를 확장할 때

첫 번째로 나머지 매개변수를 선언할 때 사용한다. 나머지 매개변수는 여러 인수를 배열로 받는데 "...restParameter"와 같은 형태로 선언해 받는다.

두 번째로 배열 요소를 확장할 때 사용되는데, 배열 합치기(array concatenation)와 배열 디스트럭처링(array destructuring)에서 사용된다.

세 번째로 객체 요소를 확장할 때 사용되는데 객체 합치기(object concatenation), 객체 디스트럭처렁(object destructuring)에 사용된다.

배열이나 객체를 보다 효과적으로 다루기 위해 타입스크립트 2.1에서는 ES6의 전개 속성(spread properties)과 레스트 속성(rest properties)의 특징이 추가되었다.

## 5.3.1. 전개 연산자를 이용한 배열 요소 확장

전개속성에 전개 연산자를 사용해 배열을 합칠 수 있다.

```typescript
let arr = [3, 4, 5];

let arr2 = [1, 2, ...arr];

// arr2의 값은 [1, 2, 3, 4, 5]이다.
```

또한 전개 속성의 위치를 바꿀 수도 있다. [1, 2, ...arr]대신 [...arr, 1, 2]라고 바꾸면 결과가 [3, 4, 5, 1, 2]가 된다.

배열 디스트럭처링에 전개 연산자를 사용한 예를 보면

```typescript
let [first, ...second] = [1, 2, 3];
// first의 값은 1이다.
// second의 값은 [2, 3]이다.
```

배열 디스트럭처링이 수행되면 배열을 해체해 여러 변수에 할당하는데, 할당받는 변수에 전개 연산자인 "..."을 사용하면 배열의 나머지 요소를 배열로 받을 수 있다.

## 5.3.2. 전개 연산자를 이용한 객체 요소 확장

객체 합치기를 수행할 때는 전개 속성에 전개 연산자인 "..."를 사용해 합칠 수 있다.

```typescript
let obj = { c: 3, d: 4, e: 5 };

let obj2 = { a: 1, b: 2, ...obj };

// obj2의 출력은 {a: 1, b: 2, c: 3, d: 4, e: 5} 이다.
```

위 예제에서 두 객체인 obj와 obj2를 합칠 때 전개 속성 "...obj"를 이용한다. 전개 연산자는 **얕은 복사 방식**으로 값을 obj2객체로 복사한다.

다음으로 객체 디스트럭처링에서 전개 연산자가 사용되는 예를 보면

```typescript
let numGroup = { n1: 1, n2: 2, n3: 3 };
let { n2, ...n13 } = numGroup;
// n2는 2의 값을 가진다.
// n13은 { n1: 1, n3: 3 }을 가진다.
```

위 코드에서 속성(n13)에 전개 연산자가 사용됐으므로 n13은 객체의 레스트 속성(rest properties)이 된다. n13은 n2 속성 외 나머지에 해당하는 객체({ n1: 1, n3: 3 })를 받는다.
