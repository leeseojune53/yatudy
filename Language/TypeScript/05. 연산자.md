# 05. 연산자

# 5.1. 기본 연산자

## 5.1.1. 산술 연산자

타입스크립트는 자바스크립트와 동일한 산술 연산자를 지원한다. 산술 연산자로는 더하기, 빼기, 곱하기, 나누기 같은 사칙연산과 나머지 연산을 수행할 수 있는 % 연산자가 있다. 이에 더해 타입스크립트는 ES7의 지수 연산자인 **를 지원하므로 Math.pow를 대체해 사용할 수 있다. 아래 예제를 보자.

```tsx
// 산술 연산자 --- #1
console.log(10 + 2, 10 - 2, 10 * 2, 10 / 2, 10 % 2);
console.log(10 ** 3);

// 타입이 다른 피연산자 간의 더하기 연산 --- #2
console.log(1 + "happy");
console.log(false + "happy");
```

지수 연산자가 포함된 10**3은 ES6나 ES5로 컴파일하면 Math.pow(10, 3)로 변환돼 컴파일 된다.

타입이 다른 피연산자 간의 더하기 연산을 보여주는데, 문자열 간의 더하기 연산은 자바스크립트처럼 문자열 결합으로 인식한다.

타입스크립트에는 더하기 연산자를 허용하지 않는 예외 상황이 있다. 예를 들어, 아래와 같은 연산식이 있다고 해보자.

```tsx
1 + false
```

위와 같은 식을 자바스크립트에서는 false 값을 0으로 인식해 정상적으로 실행하며 결과는 1이다. 그런데 타입스크립트에서는 타입 오류가 있는 것으로 판별한다.

타입스크립트에서는 **숫자 값과 불리언 값은 연산할 수 없으며**, 자바스크립트처럼 false 값을 0으로 인식하지 않는다.

또, 산술 연산자를 사용할 때 자바스크립트보다 엄격하게 타입을 검사하는 부분이 있다. 타입스크립트에서는 문자열 타입의 숫자를 연산식에 사용할 수 없다. 예를 들어, 아래와 같은 식이 있다고 해보자.

```tsx
10 / "2"
```

자바스크립트에서 위 식은 정상적으로 실행되며 결과는 5이다. 그러나 타입스크립트는 문자열 타입을 연산에 허용하지 않으므로 타입 오류가 발생한다.

위의 예제들 처럼 타입스크립트는 산술 연산자를 사용할 때 자바스크립트보다 엄격한 타입 검사를 함으로써 연산의 안정성을 높인다.

## 5.1.2. 비교, 논리, 조건 연산자

타입스크립트에서 조건문에 사용할 수 있는 연산자는 크게 세 부류가 있다.

- 비교 연산자
- 논리 연산자
- 조건 연산자

위 연산자 중에서 비교 연산자로는 다음과 같은 연산자가 있다.

[Ts 비교연산자](https://www.notion.so/0054a59b856b4a65a951edb78bb1149f)

Js는 피연산자 간에 타입이 달라도 비교할 수 있다. 예를 들어, 1==true, 1=="1"과 같이 타입이 달라도 비교 연산이 가능하다. 그런데 Ts는 1==true, 1=="1"과 같이 피연산자 간에 타입이 다르면 연산을 허용하지 않는다. 만약 1==true와 같은 연산을 한다면 오류 메시지가 나타난다.

이는 피연산자 간의 비교 연산을 할 때 타입 안전성을 고려하기 때문이다. 따라서 타입스크립트는 true == false와 같이타입이 같은 피연산자 간의 비교 연산만 허용한다. 특히 Ts는 "=="연산자 대신 "==="을, "≠" 연산자 대신 "≠="을 사용하기를 권장한다. "===", "≠=" 연산자를 사용해야 자바스크립트로 컴파일하고 나서도 타입 안정성을 보장할 수 있기 때문이다.

논리 연산자로는 다음 세 가지가 있다.

- &&
- ||
- !

비교 연산자와 달리 논리 연산자는 피연산자끼리 타입이 일치하지 않아도 된다. 따라서 1 && "true"와 같이 피연산자 간에 타입이 달라도 계산된다.

조건 연산자(?:)는 피연산자 3개를 사용하는 삼항 연산자이다. 조건 연산자의 형식은 아래와 같다.

```tsx
판별 조건 ? 표현식1 : 표현식2
```

판별 조건에 따라 표현식1과 표현식2 가운데 하나를 반환한다. 이때 판별 조건의 결과는 true/false여야 하고, true일 때는 표현식1이 실행되고, false일 때는 표현식2가 실행된다.

### 불리언 타입과 부정 연산자

불리언 타입인 true나 false는 그 자체로 참과 거짓이 자명하다 그런데 타입스크립트로 프로그래밍할 때 상황에 따라 타입 변환이 일어나기 때문에 true인지 false인지가 헷갈릴 때가 있다. 입력된 값이 숫자일 때와 문자열일 때가 그렇다. 예를 들어, 숫자 1의 타입은 number이다. 만약 숫자를 조건문에 넣으면 1은 더 이상 number가 아니라 참/거짓의 역할을 수행하며 true가 된다.

```tsx
console.log(!"hello", !!"hello");
console.log(!0, !!0, !1, !!1);
console.log(!true, !!true);
```

!! 즉 부정의 부정은 참이므로 그대로 참이다.

# 5.2. 디스트럭처링

타입스크립트는 ES6의 디스트럭처링(destructuring)을 지원한다. 디스트럭처링이라는 말의 뜻은 객체의 구조(structure)를 제거(de)한다는 의미가 있다. 디스트럭처링이라는 말의 뜻은 객체의 구조를 분해 후 할당이나 확장과 같은 연산을 수행합니다. 디스트럭처링은 자료형에 따라 다음과 같은 방식으로 나뉜다.

- 객체 디스트럭처링
- 배열 디스트럭처링

## 5.2.1. 객체 디스트럭처링

### 객체 디스트럭처링의 기본

객체 디스트럭처링 (object destructuring)은 객체 리터럴에서 변수명에 대응하는 속성값을 추출해 변수로 할당하는 데 유용하다. 이렇게 객체의 속성값을 변수에 할당하는 것을 디스트럭처링 할당(destructuring assignment)이라고 한다. 예를 들어, 객체를 변수에 디스트럭처링 할당하는 과정은 아래와 같이 이루어진다.

```tsx
let { id, country } = { id: "happy", country: 88 };
```

디스트럭처링 할당 표현식은 { id, country }와 같다. 디스트럭처링 할당 시 표현식 내부의 id와 country 변수는 객체의 속성값과 대응한다. 따라서 id에는 happy가, country에는 88이 할당된다.

디스트럭처링 할당 시 할당받을 속성이 없다면 표현식에 새롭게 정의한 변수를 선언해 초기화해 둘 수 있다.

```tsx
let { id, country=88 } = { id: "happy" };
```

디스트럭처링 할당 시 할당할 객체 속성에 새로운 이름을 부여해 할당하려면 속성 재명명(property renaming)을 이용할 수 있다.

### 디스트럭처링 매개변수 선언

함수 호출 시 객체 리터럴을 전달하고 객체 리터럴의 속성을 검사하는 것은 꽤 번거로운 작업이다.

```tsx
function printProfile(obj) {
	var name = "";
	var nationality = "";

	name = (obj.name == undeefined) ? "anonymous" : obj.name;
	nationality = (obj.name == undefined) ? "?" : obj.nationality;

	console.log(name);
	console.log(nationality);
}

printProfile({ name: "happy" });
```

위 코드의 printProfile 함수 내부를 보면 obj 객체의 속성에 name 속성이 있는지 검사하고, 없다면 기본값으로 "anonymous"를 할당하고, 있다면 객체의 속성을 할당받는다. 속성이 여럿이면 객체의 속성 검사를 위한 중복 코드가 발생한다. 객체의 특정 속성이 있는지 없는지를 타입에서 검사하고, 없다면 기본값을 할당할 수 있게 만들면 편리할 것이다. 이때 아래와 같은 형태로 함수에 디스트럭처링 매개변수를 선언한다.

```tsx
function printProfile({ 매개변수1, 매개변수2, ...}) { }
```

디스트럭처링 매개변수명은 객체의 속성명에 대응한다. 예를 들어, 함수에 디스트럭처링 매개변수를 선언해보자.

```tsx
function printProfile({ name, nationality = "?" }) {
	console.log(name);
	console.log(nationality);
}
printProfile({ name : "happy" });
```

디스트럭처링 매개변수인 name과 nationality는 전달받을 객체의 name 속성과 nationality 속성에 대응한다. 이때 디스트럭처링 매개변수는 기본값을 설정할 수 있다. 위 코드에서는 nationality의 기본값을 "?"로 설정함으로써 전달받은 객체에 속성이 없을때를 대비함. 위 코드에서 printProfile 함수는 반드시 객체를 전달해야 한다. 만약 객체 전달을 생략하려면 우항에 할당식을 추가해야 한다.

```tsx
function printProfile({name, nationality = "none"} = {name: "anonymous"}) {
    console.log(name, nationality);
}
printProfile();
printProfile({name: "happy"});
printProfile({name: "happy", nationality: "korea"})
```

위 예제는 디스트럭처링 매개변수가 할당받을 수 있게 우항에 객체를 뒀다.

이때 name은 우항식의 name 속성값을 할당받고 nationality는 기본값인 "none"가 설정돼 있으므로 생략할 수 있다.

```typescript
printProfile();
```

만약 객체에 name 속성만 포함한다면 antionality는 기본값이 있으므로 생략할 수 있다.

```typescript
printProfile({name: "happy"});
```

nationality 값을 객체에 담아 전달하면 기본값은 무시되고 전달한 nationality의 값인 "korea"가 전달된다.

```typescript
printProfile({name: "happy", nationality: "korea"});
```

### 객체 디스트럭처링 시 type 키워드 활용

type 키워드를 이용해 매개변수의 타입을 선언함으로써 객체 디스트럭처링을 수행할 수 있다. 이때 객체 디스트럭처링 시 사용할 타입은 type 키워드를 이용해 ㅐ아래와 같은 형식으로 선언한다.

```typescript
type C = { a: string, b?: number }
```

위와 같이 type 키워드를 이용해 타입 변수 C를 선언했다. 이렇게 선언한 타입 변수 C는 디스트럭처링 매개변수의 타입으로 활용할 수 있다.

```typescript
type C = { a: string, b?:number };
function fruit({a, b}: C): void {
    console.log(a, b);
}

fruit({a: "apple", b: 10});
fruit({a: "apple"});
```

### 배열 디스트럭처링

배열 디스트럭처링은 배열 요소를 간결한 방법으로 변수에 할당하는 방법을 제공한다.

```typescript
let numbers = ["one", "two", "three", "four", "five"];
```

numbers 배열에서 "onoe", "two" 요소를 추출해 nums1, nums2 변수에 할당하는 방법은

```typescript
let num1 = numbers[0];
let num2 = numbers[1];

let [nums1, nums2] = numbers;
```

위처럼 두 가지 방법이 있다.

```typescript
let [, , nums3, nums4] = numbers;

[nums4, nums3] = [nums3, nums4];
```

또한 쉼표를 이용해 부분 생략이 가능하고, 디스트럭처링을 활용해서 변숫값을 교체할 수 있다.







