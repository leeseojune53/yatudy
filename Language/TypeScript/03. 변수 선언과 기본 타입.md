# 03. 변수 선언과 기본 타입

[TOC]

# 3.1. 변수 선언

## 3.1.1. var 선언자의 특징

- 호이스팅

  선언한 변수가 스코프의 최상단으로 끌어올림 되는 현상

- 블록 레벨 스코프가 지원되지 않음

  함수 레벨 스코프 : 함수 내에서 선언한 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없는것

  블록 레벨 스코프 : 블록 {} 내에서만 유효하고 블록 외부에서는 참조할 수 없는 것

  블록 내부 변수가 블록 외부 변수에 영향을 줄 수 있다.

블록 레벨 스코프를 지원하는 선언

- let, const
- 클래스, 인터페이스, 타입 에일리어스, enum 선언

## 3.1.2. let 선언자의 특징

호이스팅 방지와 블록 레벨 스코프를 지원.

- 같은 블록 내에서 같은 이름의 변수를 중복해서 선언할 수 없음ㄹ
- 변수를 초기화하기 전에는 변수에 접근할 수 없게 해서 호이스팅을 방지
- 선언할 변수에 블록 레벨 스코프를 적용

## 3.1.3. 상수 선언

const 블록 레벨 스코프지원, 호이스팅을 일으키지 않음.뭐

# 3.2 타입 검사와 타입 선언

## 3.2.1. 점진적 타입 검사

점진적 타입 검사 : 컴파일간에 타입 검사를 수행하면서 필요에 따라 타입 선언의 생략을 허용한다. 타입 선언을 생략하면 암시적 형변환이 일어난다.

any 타입은 모든 타입의 최상위 타입, 동적 타입과 정적 타입의 경계선에 있는 타입.

## 3.2.2. 자바스크립트의 동적 타이핑

자바스크립트에는 기본 타입과 객체 타입이 있다.

기본 타입 : Number, Boolean, String과 같은 타입

객체 타입 : 객체 리터럴, 배열, 내장 객체

자바스크립트에는 타입이 있지만, 타입을 강제할 수는 없고 값을 할당할 때 타입이 추론된다.

```java
var v = 100; //number 타입
var v = "hello"; //string 타입
var v = true; //boolean 타입
```

이처럼 값을 변수에 할당할 때 타입이 정해지는 것을 동적 타이핑이라한다.

타입스크립트에서는 타입을 선언하지 않으면 입력값에 따라 타입이 결정된다.

## 3.2.3. 타입 계층도

타입스크립트는 점진적 타입 검사를 수행하는 점진적 타입 시스템을 지원한다. 따라서 타입을 생략할 수도 있지만, 암시적 형변환이나 여러 타입을 결합해 새로운 타입을 정의하는것을 허용한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d32bb535-8054-4b93-9e9a-b46c461b87b3/Untitled.png](https://mishka.kr/img/Typescript_Type.png)

타입 계층도에서 모든 타입을 받을 수 있는 any 타입이 가장 상위에 있고 그 아래로 기본 타입, 객체 타입, 기타 타입(유니언 타입, 인터섹션 타입)

### 기본 타입

기본 타입은 보편적으로 많이 사용되는 내장 타입.

- string, number, boolean
- symbol
- enum
- 문자열 리터럴

기본 타입 중 string, number, boolean은 문자열, 숫자, 불리언 값을 다룰 때 사용한다.

- string

  string는 타입스크립트 스타일 가이드를 보면 큰따옴표를 이용할 것을 권장함.

  문자열 값을 표현할 때 `를 이용할 수 있는데,`를 이용하면 줄 구분 없이 문장을 입력할 수 있고, 내장 표현식을 이요할 수 있는데 ${test} 형태로 선언하면 된다.

- number

  ES6 제안으로 10진수뿐만 아니라 16진수, 2진수, 8진수도 지원한다.

- boolean

  true 또는 false 값을 할당할 수 있다.

- symbol

  Symbol( ) 함수를 이용해 생성한 고유하고 수정 불가능한 데이터 타입, 객체 속성의 식별자로 사용됨.

- enum

  number에서 확장된 타입으로 첫 번째 Enum 요소에는 숫자 0 값이 할당된다.

  그다음 값은 특별히 초기화하지 않는 이상 1씩 증가.

- 문자열 리터럴

  문자열 리터럴 타입은 string 타입의 확장 타입으로 사용자 정의 타입에 정의한 문자열만 할당받을 수 있다.

### 객체 타입

객체 타입은 속성을 포함하고 있고, 호출 시그니처, 생성자 시그니처 등으로 구성된 타입이다.

- Array

- Tuple

- Function

- 생성자

- Class

- Interface

- Array

  배열 요소에 대응하는 타입이다. 예를 들어, 배열 요소가 1, 2, 3과 같은 숫자 값이면 number[]가 array 타입이 된다.

- tuple

  배열 요소가 n개로 정해질 때 각 요소별로 타입을 지정한 타입이다. 예를 들어, 배열 요소가 문자열과 숫자라면 [string, number]같은 형태로 타입을 정의한다.

- Function

  호출 시그니처를 포함하도록 정의한 타입.

  생성자 타입은 하나의 객체가 여러 생성자의 시그니처로 구성될 때 포함할 수 있는 타입, 생성자 타입 리터럴을 사용해 정의한다.

  생성자 타입 리터럴은 생성자 시그니처를 구성하는 타입 매개변수, 매개변수 목록, 반환 타입으로 구성된다.

- class, interface

  객체 타입으로 분류되고, 객체지향 프로그래밍이나 구조 타이핑 등에 활용된다.

### 기타 타입

그 밖에 타입스크립트에서는 다음과 같은 타입을 지원한다.

- 유니언

  2개 이상의 타입을 하나의 타입으로 정의한 타입.

- 인터섹션

  두 타입을 합쳐 하나로 만들 수 있는 타입, 예를 들어, Cat 인터페이스와 Bird 인터페이스에 선언된 속성을 합치기 위해 Cat & Bird와 같은 방식으로 선언할 수 있다.

  ```jsx
  interface Cat { leg: number; }
  interface Bird { wing: number; }
  let birdCat: Cat & Bird = { leg: 4, wing: 2 };
  ```

  위 코드에서 birdCat 변수가 인터섹션 타입인 Cat & Bird로 선언돼 있으므로 할당 객체는 leg, wing 속성만 허용함.

- 특수 타입

  타입 계층도의 가장 아래쪽에 위치한 void, null, undefined가 있다.

  void는 빈 값을 나타내는 타입, 함수에 반환값이 없을 때 void 타입을 선언할 수 있는데 undefined나 null 값을 받을 때 사용한다.

  null과 undefined 타입은 다른 모든 타입의 하위 타입(subtype)이고, undefined는 어떠한 빈 값으로도 초기화되지 않는 타입니다.

  빈 값으로도 초기화되지 않는 undefined와 달리 null 타입은 빈 객체로 초기화된다.

### 자바스크립트 타입 vs 타입스크립트 타입

- 객체 타입의 상위 타입으로 any 추가
- any 타입의 특수 타입으로 유니언 타입과 인터섹션 타입 추가
- 객체 타입의 하위 타입으로 Array, Interface, Tuple 추가
- void 타입 추가

## 3.2.4. 변수에 타입 지정

```tsx
//형식
var <변수 식별자>:<타입> = <값>
```

타입을 지정하면 변수에 할당되는 값의 타입을 쉽게 예측할 수 있게한다.

# 3.3 자바스크립트의 타입

타입스크립트에서는 자바스크립트에서 지원하는 내장 타입을 제공한다. 자바스크립트에서 지원하는 내장 타입으로는 크게 기본 타입, 객체 타입, 함수 타입이 있다.

## 3.3.1. 자바스크립트의 내장 타입

자바스크립트의 내장 타입으로는 boolean, number, string이 있다. 이러한 타입에 해당하는 값은 명시적으로 전역 객체를 통해 직접 생성할 수 있다.

Symbol( ) 함수처럼 객체 속성의 유일한 식별자로 사용하는 타입이 있고, null과 undefined처럼 null 값이거나 아직 할당되지 않았다는 의미로 쓰이는 타입도 있다.

그 밖에 object 타입이 있다. object 타입은 기본적으로 배열이나 객체 리터럴을 대상으로 하는 타입이다. 함수는 그 자체로 function 타입이다.

자바스크립트에서는 타입을 지정할 때 런타임 시 값 할당과 동시에 동적으로 타입이 결정되도록 느슨한 타입 체계를 사용한다. 반면 타입스크립트에서는 지정된 타입 값만을 할당받도록 엄격한 타입 체계를 사용한다.

null과 undefined의 차이를 살펴보면 undefined == null 비교는 undefined와 null 모두 값이 없으므로 true가 되지만, undefined === null 비교는 서로 타입이 다르므로 false가 된다.

## 3.3.2. symbol 타입

자바스크립트의 내장 타입 중 symbol 타입은 ES6에서 추가된 특징으로서 객체 속성의 유일하고 불변적인 식별자로 사용된다. symbol 타입은 Symbol함수를 이용해 다음과 같은 형태로 선언한다.

```tsx
let hello = Symbol("hello");
```

Symbol 함수는 심벌 객체를 반환한다. 이때 Symbol 함수가 유일한 식별자를 생성하는 팩토리 함수의 역할을 한다.  Symbol 함수를 호출할 때 "hello"인수는 심벌의 설명을 의미한다. 설명은 심벌에 접근할 때 사용할 수 있으며, 생략가능.

심벌 객체는 호출될 때마다 새 심벌 객체를 만든다. 즉, 유일한 심벌 객체가 만들어진다.

## 3.3.3. enum 타입

enum 타입은 ES6에 제안된 타입으로, 컴파일 시간에 평가된다. 타입 계층도로 보면 number 타입의 하위 타입으로 자바스크립트로 컴파일된 후에는 객체 리터럴이나 배열처럼 객체 타입이 된다. typeof를 통해 타입 이름을 표시하면 object로 표시된다.

enum은 명명된 숫자 상수의 집합을 정의할 때 사용한다. 명명된 숫자 상수는 enum의 속성에 대응하는 값으로서 속성은 열거해 선언할 수 있다.

const 제한자를 붙여 상수 enum으로 선언할 수 있다.

# 3.4. 타입스크립트의 내장 타입

## 3.4.1. any 타입

any 타입은 제약이 없는 타입으로 어떤 타입의 값도 받아들일 수 있다. 자바스크립트가 최소한의 정적 타입 검사를 수행하는 것처럼 최소한의 타입 검사만 수행한다.

any는 확정된 타입은 아니지만 어떤 값이든 할당받을 수 있고, any 타입은 외부 라이브러리의 연산 결과를 받는 것과 같이 타입 결과를 예측할 수 없을 때 유연한 대처가 가능함.

### any 타입은 모든 타입의 가장 최상위 타입

모든 타입은 any 타입의 하위타입이다, any 타입은 자바스크립트의 모든 값을 할당받을 수 있다.

```tsx
var a;
```

a 변수는 "var a: any"로 선언하는 것과 같다. 다만 any 타입으로 선언하면 명시적으로 타입을 선언한 것이고, any 타입을 생략하면 타입이 없는 것이다.

자바스크립트 변수는 타입이 없으므로 어떤 타입의 값이든 받아들인다. any 타입으로 선언된 변수도 마찬가지로 어떤 타입의 값이든 받아들일 수 있다. 이는 any 타입으로 선언된 변수는 최소한의 정적 타입 검사만 수행하기 때문이다.

### object 타입

object 타입은 any 타입처럼 타입 구분 없이 값을 할당할 수 있는 특성이 있어 any 타입과 비슷하다. 그런데 속성 유무를 검사하는 시점이 다른데, any 타입로 선언한 변수는 속성의 유무를 런타임 시에 검사하지만, object 타입으로 선언한 변수는 컴파일 시간에 속성의 유무를 검사한다.

따라서 OBJECT 타입의 변수에 숫자를 할당하더라도 컴파일 시에 숫자 메서드를 인식하지 못하므로 컴파일 시간에 에러가 발생한다.

### noImplicitAny 옵션

any 타입은 여러 타입의 값을 받아들여 다소 느슨한 특성이 있어 생략할 수도 있지만, 타입을 반드시 지정해야 하는 상황이 있다. 예를 들어, 함수를 선언할 때 매개변수에 타입 선언을 생략했다고 해보자.

```tsx
function add(a, b) {}
```

매개변수에 타입을 생략하면 암시적으로 any 타입이지만, 타입을 생략했으므로 도무지 어떤 타입의 값을 전달해야 할지 개발자가 코드를 보며 예측할 수 없다.

Ts 2.1버전에서는 any 타입에 대한 추론 능력이 강화돼었다. 명시적으로 any 타입을 선언하지 않아도 암시적으로 any 타입이 된다.

**any 타입임을 추론할 수 있지만, 명시적으로 any 타입임을 선언하는 것이 더 명확하므로 때로는 any 타입의 선언을 강제할 필요가 있다.**

any 타입의 사용을 강제하려면 컴파일러 옵션 중 noImplicitAny를 true로 설정하면 된다. (tsconfig.json 파일)

## 3.4.2. 배열 타입과 제네릭 배열 타입

배열은 여러 개의 값을 하나의 변수에 담아 관리하는 자료구조이다. 여러 값을 모아 담기 때문에 컬렉션이라 불리기도 한다. 타입스크립트에서 배열 타입은 두 가지 형태로 나뉜다.

- 배열 타입(array type)
- 제네릭 배열 타입(generic array type)

### 배열

배열 타입은 타입스크립트 0.9 버전부터 지원됐으며 다음과 같이 선언한다.

```tsx
let myVar: number[] = [1, 2, 3, 4, 5]
```

배열 타입은 요소 타입에 []를 붙여 선언한다.

요소타입?

string, number, boolean과 같은 내장 타입뿐 아니라 클래스나 인터페이스도 올 수 있다.

push( )메서드로 배열 요소를 추가할 수 있다.

배열 요소의 타입이 정해져 있지 않다면 any 타입으로 지정할 수 있다.

```tsx
let myVar: any[] = [1, "hi", true];
```

any 타입으로 지정하면 **어떤 요소든 배열의 요소로 추가**할 수 있다.

타입이 느슨하므로 타입을 제약하려면 유니언 타입을 이용해 선언한다.

```tsx
let myVar: (number | string | booelan)[] = [1, "hi", true];
```

### 제네릭 배열

제네릭 배열 타입은 타입스크립트 0.9 버전부터 지원되었다. 제네릭 배열 타입은 Array<T> 형태로 선언한다. 이때 T는 타입을 의미한다. 예를 들어, 제네릭 배열 타입에 [1, 2, 3] 배열을 할당하려면 다음과 같이 선언한다.

```tsx
let num: Array<number> = [1, 2, 3];
```

타입을 숫자나 문자열 타입으로 제약하려면 유니언 타입으로 선언한다.

```tsx
let num: Array<number | string> = [1, "hello"];
```

타입을 참조할 때는 타입 쿼리를 이용한다. 타입 쿼리는 typeof 연산자를 이용해 참조할 변수의 타입을 얻어와 타입을 지정한다.

```tsx
let num: Array<number | string> = [1, "hello"];
let num2: typeof num = [1, "hello"];
```

위 코드에서 num2 변수는 num 변수의 타입을 "typeof num"과 같은 방식으로 타입 쿼리를 수행해서 참조함.

제네릭 배열 타입은 내장 타입 외에 객체 타입도 받을 수 있다. 예를 들어, 배열 요소로 익명 함수를 바등려면 타입을 "() ⇒ string"으로 선언한다.

```tsx
let nums: Array<() => string> = [() => "one", () => "two"];
```

배열을 선언하는 부분과 요소를 추가하는 부분을 분리하려면 다음과 같이 작성한다.

```tsx
let num2: Array<number> = new Array<number>();
num2.push(1)
num2.push(2)
```

제네릭 타입 인수로 사용된 number는 컴파일 시점에 타입을 검사한다.

타입스크립트에서 선언한 배열 타입이든 제네릭 타입이든 컴파일 시 타입 검사를 위해 필요하고, 컴파일 후에는 타입이 제거된 배열만 남는다는 점이다.

## 3.4.3. 튜플 타입

튜플 타입은 n개의 요소로 이뤄진 배열에 대응하는 타입을 의미한다. 튜플은 배열과 비슷한데, 배열은 배열 요소의 개수에 제한이 없고 string[]처럼 특정 타입으로 배열 요소의 타입을 강제할 수 있다.

반면 튜플타입은 배열 요소에 대응하는 n개에 대한 타입이다. 예를 들어, ["tuple", 100] 배열에 대한 튜플 타입은 다음과 같이 선언한다.

```tsx
let x: [string, number] = ["tuple", 100];
```

위에서 배열에 대한 튜플 타입은 [string, number]와 같이 선언했다. 튜플 타입중 string은 배열의 첫 번째 요소에 대응하는 타입이고, number는 배열의 두 번째 요소에 대응하는 타입이다. 튜플에 선언된 타입 수와 할당될 배열의 요소 수가 정확히 일치돼야 할당이 가능해졌다.

타입스크립트 2.7 이전에는 배열의 요소가 튜플 타엡에 선언된 개수를 초과하면 유니언 타입을 적용받았다. 하지만 타입스크립트 2.7이 되면서 튜플 타입에 따라 할당 배열의 요소 수도 고정됐다.

### 3.4.4. void, null, undefined

void는 함수의 반환값이 없을 때 지정하는 타입이다. void 타입에는 null이나 undefined만 할당할 수 있다. 그 이유는 void 타입이 null과 undefined의 상위 타입이기 때문이다. 예를 들어, hello라는 함수에 반환값이 없다고 하자.

```tsx
function hello() {
		console.log("hello world");
		//반환값이 없음
}
```

반환값이 없을 때 이를 명시적으로 나타내기 위해 void를 지정한다.

```tsx
function hello(): void {
		console.log("hello world");
		//반환값이 없음
}
```

만약 변수에 void 타입을 지정한다면 반환값이 없는 채로 받는다.

```tsx
let myhello: void = hello();
```

myhello 변수는 void 타입으로 지정했으므로 void나 undefined를 할당할 수 있다. hello() 함수의 반환 타입은 void이지만, 반환값이 없으므로 실제로는 undefined가 할당된다.

void 타입은 undeined 또는 null만 할당할 수 있으므로 유용한 타입이 아니다.

**변수를 선언할 때 값을 할당하지 않았음을 나타내기 위해 선언한 변수에 null을 할당하는 것은 권장하는 방법이 아니라는 것**

null이든 undefined이든 불필요한 선언이 되거나 초기화하지 않았을 때 불안정한 연산을 초래할 수 있으므로 컴파일러 옵션에서 사용하지 못하게 막을 필요가 있다. 이를 위해 tsconfig.json에서 아래와 같이 설정한다.

```tsx
{
	"compilerOptions" : {
		"strictNullChecks": true
	}
}
```

기본적으로 변수에 할당되는 null과 undefined는 더 이상 할당되지 못하고 컴파일 오류를 발생시킨다.

반대로 strictNullChecks 옵션을 false로 지정하면 null을 허용하므로 null과 undefined할당이 가능하게 된다. 그런데 null은 값으로 인식되어 object 타입이 되므로 사용하지 않는 것이 좋고, undefined를 권장하는 경우가 많다.

**undefined와 null 간의 차이점**

undefined : 아직 초기화되지 않음.

null : 값, null을 할당하고 난 뒤 확인해 보면 변수의 타입이 object가 된다.

undeined와 null은 둘 다 구체적인 값이 없다. undefined는 선언은 됐지만 값이 할당되지 않았고, null은 값은 할당됐지만 값이 없다.

**값이 없다는 점에서 보면 undefined와 null은 같다**

```tsx
null === undefined //false
null == undefined //true
undefined == undefined //true
```

타입과 값이 같은지 비교(null === undefined) false인 이유는 두 입력값의 타입이 다르기 때문

값이 같은지 비교(null == undefined) true은 이유는 null과 undefined는 타입은 다르지만 값이 없다는 점은 값다는 의미.
