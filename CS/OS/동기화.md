# 1. 동기화

## 소프트웨어를 이용한 해결방법의 문제점

- 다중 스레드 또는 임계영역보다 복잡한 문제로 일반화하기가 쉽지 않음. 이를 위해 **세마포어**사용.
- 특히 원자적 연산에 대한 하드웨어 지원이 가능한 경우 효과적인 **모니터**사용.
- 세마포어 연산(**P연산, V연산**), 모니터 연산



## 3. 세마포어(Semaphores)

### 1. 세마포어 개요

1. #### 세마포어 개요

   동기화를 위한 도구

   - 음이 아닌 정수값을 갖는 플래그 변수
   - 다익스트라가 상호배제를 극복하기 위해 제안
   - 세마포어의 유명한 예 : 열차 진행 여부를 알리는 차단기

2. #### 세마포어 연산

   1. ##### 세마포어 변수

      1. 카운팅 세마포어 (Counting Semaphore)
         - S의 크기 : 총 사용 가능한 자원의 갯수
         - S는 자원의 개수로 초기화 됨
         - S의 범위는 한정되어 있지 않음
      2. 이진 세마포어 (Binary Semaphore, mutex)
         - S는 0 또는 1만 가질 수 있다. **초기값은 1**
         - 시스템에서 상호배제를 제공하기 때문에 **mutex**라고도 불린다.

   2. ##### 세마포어는 두 개의 표준 원자적 연산인 P연산, V연산으로 접근이 가능

      ```
      P(S){
      	while(S <= 9) no-op;
      	S = S - 1;
      }
      
      V(S){
      	S = S + 1;
      }
      
      P(S);
      	임계영역
      V(S);
      	잔류영역
      ```

      - P(S), V(S) 연산은 분리되지 않고 실행되어야 한다. (원자적 연산)
      - 한 프로세스가 세마포어의 값을 변경하면 **다른 프로세스는 동일한 세마포어를 변경할 수 없다**.
      - 세마포어를 변경하는 동안에는 **인터럽트 되지 않고** 실행되어야 한다.

      문제점 : **바쁜대기 발생**

3. #### Busy waiting(바쁜 대기)

   프로세스가 공유자원에 접근하고자 할 때, 진입구역에서 공유자원과 다른 프로세스들의 상태를 판단하는 루프를 돌면서 계속 기다리는 것

   -> 바쁜 대기를 해결하기 위한 세마포어 P(S)와 V(S)연산

   ```
   P(S) : begin
   			s.count := s.count - 1;
   			if s.count < 0 then
   			Begin
   				[호출한 프로세스를 대기큐에 넣는다];
   				block;
   			end;
   V(S) : begin
   			s.count := s.count + 1;
   			if s.count <= 0 then
   			begin
   				[대기큐에서 프로세스를 꺼낸다];
   				wakeup;
   			end;
   		end;
   ```

   - 최초에는 세마포어는 음수를 가질 수 없었으나, 위와 같이 구현하면 **음수가 될 수 있다.**
   - 세마포어가 음수라는 의미는 **대기하고 있는 프로세스의 수**를 의미한다.
   - 두 프로세스가 동시에 P(S), V(S)연산을 실행할 수 없도록 **반드시 보장**해야한다.
   - 다중처리 환경에서 모든 프로세서에서의 **인터럽트를 금지**해야 한다.
   - 위와 같은 block-wait 방식을 sleep lock이라고도 한다.

4. #### 세마포어의 문제점

   - 데드락 또는 기아 발생
   - 우선순위 역전 현상

### 2. 세마포어를 이용한 동기화 문제

#### 1. 생산자-소비자 문제

```
program producer_consumer;
var mutex : semaphore; 		//중개역할 - 이진 세마포어 (초기값 1)
var produced : semaphore; 	//소비자 완성품
var consumed : semaphore; 	//생산자 원재료
procedure producer; 		//생산자 프로세스
begin
	while true do
	begin
		[정보생산];
		p(consumed);
		p(mutex);
		[생산한 정보를 유한 버퍼에 넣는다];
		v(mutex);
		v(produced);
	end
end

procedure consumer;
begin
	while true do
	begin
		p(produced);
		p(mutex);
		[유한 버퍼에서 정보 하나를 가져온다];
		v(mutex);
		v(consumed);
		[정보소비];
	end
end
```

